"""
Exploit Matcher
Automatically matches CVEs to discovered targets based on fingerprinting.
"""

import logging
import re
from typing import Dict, List, Optional, Any
from datetime import datetime

logger = logging.getLogger(__name__)

class ExploitMatcher:
    """Matches exploits to targets based on fingerprinting data."""
    
    def __init__(self):
        self.db_manager = None
        self.fingerprint_rules = self._load_fingerprint_rules()
        
    async def initialize(self, db_manager):
        """Initialize with database manager."""
        self.db_manager = db_manager
        
    def _load_fingerprint_rules(self) -> Dict:
        """Load fingerprinting rules for different services."""
        return {
            'smb': {
                'patterns': [
                    r'Windows.*SMB.*(\d+\.\d+)',
                    r'Samba.*(\d+\.\d+\.\d+)'
                ],
                'vulns': {
                    'Windows SMB 1.0': ['CVE-2017-0144', 'CVE-2017-0145'],  # EternalBlue
                    'Windows SMB 2.0': ['CVE-2020-0796'],  # SMBGhost
                }
            },
            'http': {
                'patterns': [
                    r'Apache/(\d+\.\d+\.\d+)',
                    r'nginx/(\d+\.\d+\.\d+)',
                    r'IIS/(\d+\.\d+)'
                ],
                'vulns': {
                    'Apache 2.4.49': ['CVE-2021-41773'],
                    'Apache 2.4.50': ['CVE-2021-42013'],
                    'nginx 1.20.1': ['CVE-2021-23017'],
                }
            },
            'ssh': {
                'patterns': [
                    r'OpenSSH_(\d+\.\d+)'
                ],
                'vulns': {
                    'OpenSSH 8.0': ['CVE-2020-14145'],
                    'OpenSSH 7.4': ['CVE-2018-15473'],
                }
            },
            'mysql': {
                'patterns': [
                    r'MySQL.*(\d+\.\d+\.\d+)'
                ],
                'vulns': {
                    'MySQL 5.7.37': ['CVE-2022-21245'],
                    'MySQL 8.0.28': ['CVE-2022-21270'],
                }
            }
        }
        
    async def find_matches(self, target_info: Dict) -> List[Dict]:
        """Find matching exploits for a target."""
        matches = []
        
        # Get target services
        services = target_info.get('services', [])
        os_info = {
            'type': target_info.get('os_type', ''),
            'version': target_info.get('os_version', '')
        }
        
        for service in services:
            service_matches = await self._match_service(service, os_info)
            matches.extend(service_matches)
            
        # Sort by confidence score
        matches.sort(key=lambda x: x.get('confidence', 0), reverse=True)
        
        return matches
        
    async def _match_service(self, service: Dict, os_info: Dict) -> List[Dict]:
        """Match exploits for a specific service."""
        matches = []
        
        service_name = service.get('service', '').lower()
        service_version = service.get('version', '')
        service_banner = service.get('banner', '')
        
        if service_name not in self.fingerprint_rules:
            return matches
            
        # Try to extract version from banner
        if not service_version and service_banner:
            service_version = self._extract_version(service_banner, service_name)
            
        # Check for known vulnerabilities
        rules = self.fingerprint_rules[service_name]
        
        for vuln_signature, cve_list in rules.get('vulns', {}).items():
            confidence = self._calculate_confidence(
                service_name, service_version, vuln_signature, os_info
            )
            
            if confidence > 0.5:  # Minimum confidence threshold
                for cve in cve_list:
                    match = {
                        'cve': cve,
                        'service': service_name,
                        'port': service.get('port'),
                        'confidence': confidence,
                        'signature': vuln_signature,
                        'detected_version': service_version,
                        'exploit_available': await self._check_exploit_available(cve)
                    }
                    matches.append(match)
                    
        return matches
        
    def _extract_version(self, banner: str, service: str) -> str:
        """Extract version from service banner."""
        if service in self.fingerprint_rules:
            patterns = self.fingerprint_rules[service].get('patterns', [])
            
            for pattern in patterns:
                match = re.search(pattern, banner, re.IGNORECASE)
                if match:
                    return match.group(1)
                    
        return ""
        
    def _calculate_confidence(self, service: str, version: str, 
                            signature: str, os_info: Dict) -> float:
        """Calculate confidence score for a potential match."""
        confidence = 0.0
        
        # Base confidence for service match
        if service.lower() in signature.lower():
            confidence += 0.3
            
        # Version-based confidence
        if version:
            if version in signature:
                confidence += 0.4
            elif self._version_in_range(version, signature):
                confidence += 0.3
            else:
                confidence += 0.1
        else:
            confidence += 0.1  # Lower confidence without version
            
        # OS-based confidence
        os_type = os_info.get('type', '').lower()
        if os_type:
            if os_type in signature.lower():
                confidence += 0.2
            elif 'windows' in signature.lower() and 'windows' in os_type:
                confidence += 0.2
            elif 'linux' in signature.lower() and 'linux' in os_type:
                confidence += 0.2
                
        # Additional factors
        confidence += 0.1  # Base probability
        
        return min(confidence, 1.0)
        
    def _version_in_range(self, version: str, signature: str) -> bool:
        """Check if version falls within vulnerable range."""
        # Simplified version comparison (real implementation would be more robust)
        try:
            parts = version.split('.')
            major = int(parts[0]) if len(parts) > 0 else 0
            minor = int(parts[1]) if len(parts) > 1 else 0
            
            # Extract version from signature
            sig_match = re.search(r'(\d+)\.(\d+)', signature)
            if sig_match:
                sig_major = int(sig_match.group(1))
                sig_minor = int(sig_match.group(2))
                
                # Simple range check (could be more sophisticated)
                return (major == sig_major and minor <= sig_minor + 2)
                
        except (ValueError, IndexError):
            pass
            
        return False
        
    async def _check_exploit_available(self, cve: str) -> bool:
        """Check if exploit module is available for CVE."""
        # In real implementation, this would check loaded exploit modules
        # For demo, we'll simulate some available exploits
        available_exploits = [
            'CVE-2017-0144',  # EternalBlue
            'CVE-2021-44228', # Log4Shell
            'CVE-2022-26134', # Confluence RCE
            'CVE-2023-23397', # Outlook
        ]
        
        return cve in available_exploits
        
    async def auto_match_targets(self) -> Dict:
        """Automatically match all targets against CVE database."""
        if not self.db_manager:
            return {'error': 'Database manager not initialized'}
            
        targets = await self.db_manager.get_targets()
        all_matches = {}
        
        for target in targets:
            target_matches = await self.find_matches(target)
            if target_matches:
                all_matches[target['ip_address']] = target_matches
                
        return all_matches