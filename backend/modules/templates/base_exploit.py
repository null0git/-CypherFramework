"""
Base Exploit Module Template
All exploit modules should inherit from this base class.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import logging

logger = logging.getLogger(__name__)

class BaseExploit(ABC):
    """Base class for all exploit modules."""
    
    # Module metadata (override in subclasses)
    name = "Unknown Exploit"
    description = "Base exploit template"
    author = "Unknown"
    version = "1.0"
    module_type = "exploit"
    
    # Exploit-specific metadata
    cve = ""
    references = []
    target_os = []
    target_services = []
    difficulty = "normal"  # trivial, easy, normal, hard, expert
    reliability = "normal"  # poor, average, normal, good, excellent
    
    def __init__(self):
        self.options = self._default_options()
        self.required_options = self._required_options()
        
    @abstractmethod
    def _default_options(self) -> Dict[str, Any]:
        """Return default options for this exploit."""
        return {
            'RHOSTS': {'value': '', 'required': True, 'description': 'Target host(s)'},
            'RPORT': {'value': 80, 'required': True, 'description': 'Target port'},
            'TIMEOUT': {'value': 30, 'required': False, 'description': 'Connection timeout'},
        }
        
    @abstractmethod
    def _required_options(self) -> List[str]:
        """Return list of required option names."""
        return ['RHOSTS', 'RPORT']
        
    @abstractmethod
    async def check(self, target: Dict[str, Any]) -> Dict[str, Any]:
        """
        Check if target is vulnerable.
        
        Args:
            target: Target information dict
            
        Returns:
            Dict with 'vulnerable' (bool), 'confidence' (float), 'details' (str)
        """
        pass
        
    @abstractmethod
    async def run(self, target: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the exploit.
        
        Args:
            target: Target information dict
            
        Returns:
            Dict with 'success' (bool), 'session_id' (str), 'output' (str), 'error' (str)
        """
        pass
        
    def set_option(self, name: str, value: Any):
        """Set an option value."""
        if name in self.options:
            self.options[name]['value'] = value
        else:
            raise ValueError(f"Unknown option: {name}")
            
    def get_option(self, name: str) -> Any:
        """Get an option value."""
        if name in self.options:
            return self.options[name]['value']
        raise ValueError(f"Unknown option: {name}")
        
    def validate_options(self) -> Dict[str, Any]:
        """Validate all required options are set."""
        missing = []
        
        for option_name in self.required_options:
            if option_name in self.options:
                option = self.options[option_name]
                if option.get('required', False) and not option.get('value'):
                    missing.append(option_name)
            else:
                missing.append(option_name)
                
        if missing:
            return {'valid': False, 'missing': missing}
            
        return {'valid': True, 'missing': []}
        
    def get_info(self) -> Dict[str, Any]:
        """Get exploit information."""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'version': self.version,
            'cve': self.cve,
            'references': self.references,
            'target_os': self.target_os,
            'target_services': self.target_services,
            'difficulty': self.difficulty,
            'reliability': self.reliability,
            'options': self.options
        }
        
    async def _connect_target(self, host: str, port: int, timeout: int = 30) -> Optional[Any]:
        """Helper method to connect to target."""
        import socket
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((host, port))
            return sock
        except Exception as e:
            logger.error(f"Connection failed to {host}:{port} - {e}")
            return None
            
    async def _send_http_request(self, host: str, port: int, request: str, 
                                ssl: bool = False, timeout: int = 30) -> Optional[str]:
        """Helper method to send HTTP request."""
        import socket
        import ssl as ssl_module
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            
            if ssl:
                context = ssl_module.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl_module.CERT_NONE
                sock = context.wrap_socket(sock, server_hostname=host)
                
            sock.connect((host, port))
            sock.send(request.encode())
            
            response = b""
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                if b"\r\n\r\n" in response:
                    break
                    
            sock.close()
            return response.decode(errors='ignore')
            
        except Exception as e:
            logger.error(f"HTTP request failed to {host}:{port} - {e}")
            return None